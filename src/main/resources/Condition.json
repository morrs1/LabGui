{
  "2 лабораторная": {
    "1 задание": "Напишите программу, выводящую на экран таблицу,\nсодержащую минимальные и максимальные значения для всех простых\nчисловых типов.",
    "2 задание": "Дан массив из 20 целых переменных. Конкретные значения\nдля элементов задаются в конструкции инициализации. Найти среднее\nгеометрическое отрицательных элементов.",
    "3 задание": "Радар посылает сигнал, ловит его отражение и по времени\nраспространения сигнала определяет расстояние до предмета. Есть\nнекоторое расстояние R. Сигнал от предметов, расположенных на\nбольших расстояниях слишком слабый и радар не может обнаружить их\nобнаружить. Радар используется для охраны некоторого объекта.\nОпределено расстояние r меньшее R. Если какой-то предмет\nоказывается слишком близко к объекту охраны, на расстоянии меньшем\nr, объявляется тревога. Даны (заданы в самой функции main)\nкоординаты (два вещественных значения) некоторого предмета в\nокрестности объекта (в Декартовой прямоугольной системе координат).\nОпределить и вывести на экран сообщение: если предмет далеко - \"Не\nобнаружен\", если на расстоянии большем r, но меньшем или равном R\n- \"Обнаружен\", если на расстоянии меньшем или равном r - \"Тревога\".",
    "4 задание": "Преобразуйте предыдущую программу так, чтобы можно\nбыло задавать расстояния R и r, координаты предмета через командную\nстроку. Протестируйте программу для всех возможных вариантов\nпопадания точки.",
    "5 задание": "Напишите программу, получающую через командную\nстроку целое десятичное число и отображающую на экране само это\nчисло и его представление в двоичной, восьмеричной и\nшестнадцатеричной системах счисления.",
    "6 задание": "В стандарте Unicode-16 под знаки Кириллицы (включая\nсимволы украинского, сербского, македонского и т.д. языков, а также\nстарославянского) отведен диапазон кодов 0x0400 - 0x04FF. Создайте\nметод для отображения в виде таблицы непрерывного набора Unicode-\nсимволов, которому через аргументы передаются стартовый код, число\nвыводимых строк и столбцов таблицы. Напишите программу, которая\nиспользует метод для вывода символов Кириллицы (стартовый код\n0x0400, 16 строк, 16 столбцов, а, затем, для вывода некоторых знаков\nденежных единиц (например, бразильского крузейро, индийской рупии,\nевро, гривны, турецкой лиры, рубля, биткоина), стартовый код 0x20a0, 2\nстроки, 16 столбцов. ",
    "7 задание": "Написать приложение для реализации следующего\nалгоритма: дана строка, посчитать и вывести на экран следующие\nзначения: количество букв, сколько из них строчных, сколько прописных,\nколичество цифр, сколько из них арабских, сколько не арабских,\nколичество других символов и общее количество всех символов.",
    "9 задание": "Используйте методы indexOf класса String для решения и\nпрограммной реализации следующей задачи. Посчитать, сколько раз\nзаданная подстрока встречается в указанной строке.",
    "10 задание": "Напишите программу для решения следующей задачи.\nДана строка. Найти все ее циклические перестановки. Например, для\nстроки “abcd” это строки “abcd”, “bcda”, “cdab”, “dabc”."
  },
  "3 лабораторная": {
    "1 задание": "Вывести на экран в виде таблицы (протабулировать)\nзначения функций sin(x), ex / x * lg(x) для значений x из интервала\n[π/15..pi], меняющихся с шагом π/15. Для столбца со значениями\nаргумента нужно использовать представление с фиксированной точкой,\nширина столбца - 10 позиций, точность - 5 знаков после запятой. Для\nстолбца со значениями функции: экспоненциальное представление,\nширина 15 позиций, точность 7 знаков.",
    "2 задание": "Реализовать алгоритм нахождения наибольшего\nотрицательного элемента двумерного массива, содержащего\nпроизвольное число строк и столбцов и, быть может, различное число\nэлементов в каждой строке.",
    "3 задание": "Написать приложение для реализации следующего\nалгоритма: упорядочить по возрастанию элементы каждой строки\nматрицы 3x3. Вывести матрицу на экран до сортировки и после.",
    "4 задание": "Создать класс с методом, реализующим следующий\nалгоритм: на плоскости размещены две окружности, центр первой в\nкоординатах x1, y1 и ее радиус r1, а центр и радиус другой в x2, y2, r2,\nконкретные значения передаются методу через его аргументы или\nхранятся в полях класса. Определить пересекаются ли окружности в\nодной точке (касаются), в двух точках, совпадают, не пересекаются и ни\nодна из окружностей не является вложенной в другую, вторая\nокружность вложена в первую, первая вложена во вторую. Метод\nдолжен возвращать целое значение, соответствующее возникшей\nситуации. Протестировать работу метода, запрашивая у пользователя\n(ввод с клавиатуры) параметры окружностей и выводя сообщение о их\nвзаимоположении.",
    "5 задание": "Измените класс из предыдущего задания так, чтобы в нем\nбыл определен подходящий перечислимый тип, и чтобы метод\nвозвращал значение этого перечислимого типа.",
    "6 задание": "Написать метод, реализующий алгоритм численного\nинтегрирования левыми прямоугольниками. В программе-тесте\nпротабулировать функцию y(x) = ex - x3 на интервале, который задает\nпользователь (например, от 0 до 4) с постоянным шагом так, чтобы\nполучить значения аргумента x и функции y в 101 точке (два массива).\nПередать массивы методу интегрирования. Посчитать значение\nинтеграла аналитически и сравнить результат, возвращаемый методом\nс точным значением.",
    "7 задание": "Написать приложение для преобразования целого числа из\nдесятичного представления в представление в заданной системе\nсчисления (от 2 до 8 включительно). Для проверки правильности работы\nпрограммы используйте методы классов-оболочек toString(value, base),\nгде value - преобразуемое десятичное значение, base - основание\nсистемы счисления, в которую нужно переводить value. Например,\nString val3 = Integer.toString( 12, 3 ); // 12 в троичную систему счисления\n(в своем алгоритме использовать toString нельзя!).",
    "8 задание": "Реализуйте вычисление значения полинома n-й степени по\nсхеме Горнера. Суть схемы в том, что запись полинома\nP(x) = an * xn + an-1 * xn-1 + … + a0 преобразуется в\nP(x) = (…((an * x + an-1) * x + an-2) * x + …) * x + a0\nПолином в программе представляется массивом его коэффициентов\n(массив из n+1 элемента), а сами вычисления выполняются в цикле так,\nчто в начале P = an * x + an-1, а затем на каждой итерации P = P * x + ai.",
    "9 задание": "1) Сформируйте регулярное выражение для проверки того,\nсодержит ли заданная строка представление одиннадцатизначного\n(федерального) телефонного номера российского оператора связи. В\nначале должны быть либо символы +7, либо 8. Кроме того, номер может\nсодержать в определенных позициях пробелы, дефисы, круглые скобки.\nНапример, правильными будут следующие варианты\n16\n+79043781661 +7 904 378 1661 +7 904 378 16 61\n+7-904-378-16-61 +7(904)3781661 +7(904) 378-16 61\n89043781661 8 904 378-16-61\nКруглыми скобками могут быть выделены только три цифры после\nпрефикса +7 или 8. Пробелы могут быть после префикса, после трех\nцифр, следующих за префиксом, после следующих трех цифр, после\nследующих двух цифр. На тех же позициях могут встречаться дефисы.\nПроверьте корректность полученного регулярного выражения на\nприведенных выше примерах и для других вариантов (допустимых и не\nдопустимых) представления телефонных номеров.\n2) Сформируйте регулярное выражение для проверки того, содержится\nли где-то в заданной строке представление семизначного\n(муниципального) телефонного номера Ростова-на-Дону. Номер\nдолжен начинаться с цифры 2 или 3, эта цифра может быть отделена\nот остальной части номера пробелом или дефисом (а может быть и не\nотделена ничем), далее каждая из трех пар цифр также может\nотделяться пробелом или дефисом. Например, содержимое следующей\nстроки должно соответствовать построенному регулярному выражению\n\"Мои номера 220-30-40 и 8904-378-16-61 не считая служебных\"",
    "10 задание": "Используйте регулярные выражения из предыдущего\nзадания для того, чтобы извлечь из строки\n\"Мои номера 220-30-40 и 8904-378-16-61 не считая служебных\"\nвсе содержащиеся в ней номера телефонов."
  },
  "4 лабораторная": {
    "1 задание": "Создайте класс Car, представляющий понятие\n\"автомобиль\". Каждый автомобиль должен иметь, как минимум,\nследующие характеристики: регистрационный знак, марка, вид, цвет,\nмощность двигателя, количество колес. Для вновь созданного,\nконкретного автомобиля такие характеристики как марка, вид, цвет,\nмощность двигателя, количество колес должны быть заданы\nнепременно, но регистрационного номера у него до поры до времени\nможет и не быть (а может и быть). Все характеристики автомобиля,\nкроме марки, вида и количества колес можно изменять в процессе его\nэксплуатации. Вид автомобиля - легковой, грузовой, автобус. Создайте\nи используйте для задания вида автомобиля перечислимый тип. Для\nлегковых, грузовых автомобилей и автобусов с нормальным\nкреплением знака (тип 1) согласно ГОСТ Р 50577-2018 [6] знак имеет\nследующий формат: X 000 XX 00 RUS или X 000 XX 000 RUS. Здесь 0 в\nреальном знаке заменяется какой-то арабской цифрой, а X - одной из\n12 букв кириллицы (в верхнем регистре), написание которой совпадает\nс написанием латинской буквы: А, В, Е, К, М, Н, О, Р, С, Т, У, Х. Попытка\nзадания неправильного знака должна пресекаться соответствующим\nметодом класса. Для проверки используйте регулярное выражение.\nСоздайте код для тестирования класса Car с заданием начальных\nхарактеристик, запросом новых значений для тех характеристик,\nкоторые можно изменять и выводом на экран текущих значений всех\nхарактеристик.",
    "2 задание": "В Java отсутствует стандартный класс для представления\nкомплексных чисел. Создайте такой класс (Complex), поддерживающий\nоперации получения действительной, мнимой частей числа, сложения,\nвычитания, умножения, деления, комплексного сопряжения, проверки\nдвух чисел на равенство, вывода значения комплексного числа в\nалгебраической и тригонометрической формах. Так как действительное\nчисло, это комплексное число с нулевой мнимой частью, должны\nподдерживаться также арифметические операции, в которых один из\nаргументов действительное число (тип double).\nАлгебраическая форма: z = x + i*y, x - действительная часть, y -\nмнимая часть, i - мнимая единица\n28\nТригонометрическая форма: z = r*(cos(φ)+i*sin(φ)), r - модуль числа\n|z| =√x2 + y2, φ - аргумент числа arg(z) = atctgy\nx\nz1 и z2 равны, если x1 = x2 и y1 = y2\nкомплексно сопряженное z̅ = x - i*y\nСумма z3 чисел z1 = x1 + i*y1 и z2 = x2 + i*y2: z3 = (x1+x2) + i*(y1+y2)\nРазность z1 - z2: z3 = (x1-x2) + i*(y1-y2)\nПроизведение z1 * z2: z3 = (x1*x2-y1*y2) + i*(x1*y2+x2*y1)\nЧастное z1 / z2: z3 = x1∗x2+y1∗y2\nx2\n2+y2\n3 + i ∗ x2∗y1−x1∗y2\nx2\n2+y2\n3",
    "3 задание": "Реализуйте методы для вычисления элементарных\nфункций комплексного переменного z = x + i*y: ez = ex(cos(y)+i*sin(y)),\nsin(z) = ei∙z−e−i∙z\n2∙i , cos(z) = ei∙z+e−i∙z\n2 , tan(z) =sin(\uD835\uDC67)\ncos(\uD835\uDC67) = ei∙z−e−i∙z\n(ei∙z+e−i∙z)∙i, arctan(z) = cos(\uD835\uDC67)\nsin(\uD835\uDC67)\n= (ei∙z+e−i∙z)∙i\nei∙z−e−i∙z , sh(z) = ez−e−z\n2 , ch(z) = ez+e−z\n2 , th(z) = sh(\uD835\uDC67)\nch(\uD835\uDC67) = ez−e−z\nez+e−z, cth(z) = ch(\uD835\uDC67)\nsh(\uD835\uDC67) =\nez+e−z\nez−e−z. Формула Эйлера: ei*x = cos(x)+i*sin(x), x - действительное число.\nОрганизуйте методы так, чтобы их можно было вызывать, не создавая\nобъекты класса, которому принадлежат эти методы. Прежде чем писать\nкод, ответьте себе на вопрос, должны ли эти методы быть методами\nкласса Complex, созданного в предыдущем задании?",
    "4 задание": "В Задании 1 двигатель автомобиля представлен только\nодной своей характеристикой - мощностью. А самом деле каждый\nдвигатель имеет серийный (заводской) номер, и, помимо мощности,\nрабочий объем, расход топлива, вид топлива, число цилиндров и т.д.\nПоэтому для такого важного понятия удобно ввести отдельный класс.\nСоздайте класс Engine, включив в него несколько важных характеристик\nдвигателя и методы доступа к этим характеристикам. Определите и\nреализуйте нужный конструктор (или конструкторы) класса Engine.\nЗамените в классе Car поле \"мощность\" на поле \"двигатель\" (engine).\nИзмените код тестирования для проверки работоспособности новой\nверсии класса Car и класса Engine.",
    "5 задание": "В Заданиях 1, 4 вид автомобиля задается как\nпредопределенное значение. Появление новых видов будет приводить\nк необходимости модифицировать класс Car. Кроме того, для новых\nвидов автомобилей правила формирования регистрационного знака\nмогут быть другими. Более гибкое решение - каждый вид автомобиля\nпредставлять собственным классом. С другой стороны, все автомобили\n29\nбудут обладать одинаковым набором некоторых базовых\nхарактеристик. Не разумно при возникновении нового вида автомобиля\nвсякий раз повторять в нем объявления этих базовых характеристик и\nопределять методы доступа к ним. Нужно использовать семейство\nродственных классов, в котором один (Car) будет содержать все общие\nхарактеристики, а другие - классы для конкретных видов автомобилей\nдополнительные характеристики и/или конкретные значения для\nбазовых характеристик. Измените нужным образом класс Car, создайте\nклассы для следующих видов автомобилей: легковой, грузовой,\nавтобус, специальный (например, пожарная машина, или автомобиль\nдля дипломатических миссий). Для специальных автомобилей\nпридумайте свою схему формирования регистрационного знака (или\nвозьмите из ГОСТ Р 50577-2018 [6]).",
    "6 задание": "В Задании 5 класс Car содержит общую функциональность\nсемейства автомобилей разных видов, но не представляет какие-то\nконкретные автомобили. Не логично разрешать пользователям\nсоздавать в программе экземпляры класса Car. Кроме того, некоторые\nметоды доступа к базовым характеристикам автомобиля, заданные в\nклассе Car не должны переопределяться в классах-наследниках. Если\nэто будет сделано случайно или преднамеренно, изменится базовое\nповедение некоторых автомобилей, а этого не должно происходить по\nлогике организации семейства классов автомобилей. Нужно запретить\nнаследникам переопределять такие методы базового класса. Наконец,\nнужно задаться вопросом, насколько расширяемой должна быть наша\nсистема родственных классов. Например, есть ли какие-то особые\nформы автобусов, для которых нужно построить класс-наследник\nимеющегося класса? А для других классов, представляющих\nавтомобили? Сделайте так, чтобы, по крайней мере, класс\nпредставляющий автобусы нельзя было расширять.",
    "7 задание": "Создайте класс \"Автобаза\". На базе может размещаться\nнекоторое фиксированное количество автомобилей разных видов\n(классы производные от Car). Для хранения объектов, представляющих\nавтомобили нужно использовать массив фиксированного размера.\nМаксимально возможный размер для конкретной автобазы (конкретного\nобъекта класса) задается при создании объекта. Каждый автомобиль\nможет находиться в одном из трех допустимых состояний: на базе, в\nрейсе, в ремонте. Нужно обеспечить добавление нового автомобиля\n(если еще есть место для размещения автомобиля). Удаление\n30\n(списание) автомобиля. Отправку исправного автомобиля в рейс.\nОтправку неисправного автомобиля в ремонт. Возврат автомобиля из\nрейса или из ремонта. Отображение на экране списка находящихся на\nбазе исправных автомобилей, списка автомобилей, находящихся в\nрейсе, списка неисправных автомобилей (отдельные методы).",
    "8 задание": "Средство построения графиков функций может\nгенерировать рисунки подобные следующему. Отвлекаясь пока от\nграфического изображения спроектируйте\nсистему классов для решения такой задачи\nв объектно-ориентированном стиле (в виде\nUML-диаграммы классов). Каждое важное\nпонятие задачи нужно представить\nсобственным классом. Например, на\nрисунке есть собственно весь график, на\nнем отдельные кривые, оси координат,\nкоординатная сетка, пояснения. Это все\nважные понятия в решаемой задаче.\nКаждый класс отвечает за свой функционал. В частности, каждый класс\nотвечает за прорисовку своих объектов. Определите, какие параметры\nдолжны хранить соответствующие классы, какие у них должны быть\nметоды и изобразите на UML-диаграмме классов сами классы, их поля\nи методы, отношения между классами.",
    "9 задание": "Создайте классы для построенной в Задании 7 UML-\nдиаграммы классов. Вместо реального рисования нужно обеспечить\nвывод на экран текстовой информации со значениями параметров\nобъектов соответствующих классов."
  },
  "5 лабораторная": {
    "1 задание": "Создайте обобщенный класс Pair, представляющий\nпонятие \"пара значений\". Такой класс оказывается полезным в\nситуациях, когда нужно использовать два связанных друг с другом\nзначения. Например, алгоритм поиска наибольшего элемента\nзаданного массива может вернуть само это наибольшее значение и\nзначение позиции (индекса) первого элемента массива с таким\nзначением. Типы элементов пары могут быть произвольными (но\nссылочными) и в общем случае не совпадающими. Необходимо\nпредусмотреть конструктор (или конструкторы) для инициализации\nвновь созданных пар, возможность получение/изменения каждого из\n14\nзначений пары (можно, как это сделано, например, в стандартном\nшаблоне pair в С++ просто использовать открытые поля first и second) и\nметод make_pair для создания пары значений, который можно вызывать\nдаже если у нас пока нет ни одного объекта класса Pair.",
    "2 задание": "Мешок (Bag) - это емкость фиксированного размера, в\nкоторую можно складывать различные предметы. Поднимая мешок мы\nего встряхиваем и предметы перераспределяются в мешке\nпроизвольным образом. Из мешка достается тот предмет, который\nподвернулся под руку первым, то есть какой-то из имеющихся, но\nнеизвестно какой. Другими словами, Bag - это контейнер, в который\nновые элементы добавляются в произвольную (будем считать\nслучайную) позицию и удаляются из случайно выбранной позиции.\nСоздайте (НЕ ОБОБЩЕННЫЙ!) класс Bag в котором элементы хранятся\nв массиве (какого типа должны быть элементы массива если по\nтребованиям задачи Bag может хранить предметы любых типов?).\nРазмер массива (предельный размер конкретного \"мешка\") указывается\nв конструкторе при создании объекта и дальше меняться не может.\nНужно предусмотреть методы для добавления, удаления (этот метод\nдолжен возвращать удаленный элемент) элементов, метод\nвозвращающий (какой-то) элемент и метод, возвращающий значение\nтекущего размера Bag. Какие методы (или один метод) Bag не должны\nпереопределяться в классах-потомках? Запретите их (или его)\nпереопределение.\nМетод random() класса Math возвращает псевдослучайное действитель-\nное значение в диапазоне от 0.0 до 1.0, включая 0.0 но не включая 1.0.\nЧтобы получить псевдослучайное целое значение из диапазона [0, size-\n1] можно использовать выражение (int)Math.round(Math.random()*(size-\n1)).\nПротестируйте работоспособность класса Bag для элементов разного\nтипа (Integer, String, …).",
    "3 задание": "Создайте НЕОБОБЩЕННЫЙ класс PairBag, представля-\nющий \"мешок\" для хранения пар значений. Используйте созданные\nраньше обобщенный класс Pair и необобщенный класс Bag. Прежде\nвсего, определите, какое отношение между классами Bag и PairBag\nследует использовать. Как и следует из названия, объекты PairBag\nдолжны хранить только пары значений (не могут хранить отдельные)\nзначения. Методы должны работать с парами (получать/возвращать).\n15\nПри этом, в одном и том же объекте PairBag одновременно могут\nхраниться могут пары c разными типами значений, например,\nPair<Integer,Integer> и Pair<Integer,String>.",
    "4 задание": "Хранение в контейнере пар разного типа обычно приводит\nк неопределенности при использовании пар. Такой проблемы не будет,\nесли типы пар одинаковые. Если тип первого значения пары T1, а тип\nвторого значения пары T2, то все пары в контейнере должны иметь тип\nPair<T1,T2>. Создайте обобщенный класс GPairBag для хранения пар\nодинакового типа. В реализации не используйте стандартные\nконтейнеры Java. Используйте те классы, которые Вы реализовали при\nрешении предыдущих заданий этой лабораторной работы. Начните с\nопределения того, какое отношение между GPairBag и PairBag удобно\nиспользовать.",
    "5 задание": "Создайте обобщенный класс GenericPairBag для хранения\nпар одинакового типа, используя подходящий стандартный\nобобщенный контейнерный класс Java, например, ArrayList.",
    "6 задание": "Проводится спортивное соревнование, турнир, среди N\nкоманд. Нужно провести жеребьевку, то есть определить пары команд,\nкоторые будут проводить игры друг с другом. Для этого записки с\nназваниями команд складываются в \"мешок\", перемешиваются, затем\nпоследовательно извлекаются из мешка и две подряд выбранные\nзаписки определяют пару играющих друг с другом команд.\nПолучившиеся пары помещаются в другой \"мешок\". Затем, пока в этом\n\"мешке\" еще что-то есть, из него выбирается какая-то пара и\nпользователю задается вопрос о том, какая команда выиграла, первая\nили вторая (игра проводится до победы одной из команд, ничьей быть\nне может). Названия выигравших команд складываются в первый\n\"мешок\". Теперь их будет N/2 штук. Процесс продолжается до тех пор,\nпока не останутся две команды. Победившая команда является\nпобедителем всего турнира. Напишите программу, реализующую\nописанный выше процесс проведения турнира. Число команд-\nучастников N задается пользователем. Очевидно, что N не может быть\nпроизвольным. Если пользователь дает недопустимое значение N\nможно задать значение по умолчанию, например, 8. \"Мешки\" должны\nбыть представлены каким-нибудь подходящим стандартным классом-\nконтейнером (или классом Bag) и классом GenericPairBag. Имена\n16\nкоманд можно генерировать автоматически (\"Команда1\", \"Команда2\",\n…).",
    "7 задание": "Создайте класс DList, содержащий два поля - список\nзначений произвольного типа T1 и список списков значений\nпроизвольного типа T2. Работа с полями должна быть согласованной,\nто есть, например, при добавлении новых значений должны\nуказываться одновременно целое значение и список целых значений,\nсоответственно целое значение добавляется в первое поле класса,\nсписок во второе, Таким образом, каждому элементу в позиции i первого\nполя (списка) соответствует список в позиции i второго поля (списка\nсписков). Удалять и получать информацию можно указав либо позицию\ni, либо значение первого поля. Например, первое поле может содержать\nсписок {1, 2, 3, 4, 5}, с каждым элементом этого списка могут быть\nсвязаны, например, такие списки: {1}, {1,1}, {1,2}, { {1,3}, {2,2} }, {2,3}. То\nесть со всеми элементами, кроме 4, связано по одному списку, а со\nзначением 4 связаны два списка.",
    "8 задание": "Реализуйте алгоритм выдачи указанной суммы денег\n(целое значение) минимальным количеством монет из заданного\nнабора методом динамического программирования. Алгоритм должен\nвозвращать не только количество монет, но и все возможные\nкомбинации монет, обеспечивающие оптимальную выдачу суммы.\nИспользуйте в реализации класс DList. Протестируйте работу\nалгоритма для разных наборов монет (например, 1, 2, 5, 10 и 1, 4, 7, 9).\nЗдесь первое поле DList будет содержать набор промежуточных\nрезультатов, а второе поле - списки номиналов монет, которыми должна\nбыть выдана сумма, соответствующая промежуточному результату.\nПример в задании 7 соответствует решению задачи выдачи суммы 5\nмонетами номиналов 1, 2, 3.",
    "9 задание": "Создайте обобщенный класс HashFunction<K> с одним\nобъявленным абстрактным методом int hash(K s). При создании объекта\nкласса HashFunction ему должна передаваться информация о размере\nтаблицы – это определяет, какие целые значения (из какого диапазона)\nдолжна выдавать функция. Создайте обобщенный класс HashTable для\nпредставления хэш-таблицы в виде массива списков. Учтите, что в\nтаблице хранятся данные одного типа T, а поиск в таблице может\nосуществляться по другому типу K (например, поиск проводится не по\nвсей записи, а только по одному ее полю). Это, в частности накладывает\nограничение на тип элементов таблицы. Нужно уметь проверять, что\nконкретный элемент содержит значение (например, отдельное поле) по\nкоторому хэш-функция генерирует свое значение. То есть тип T должен\nсодержать реализацию некоторого метода (например, boolean\n18\ncontains(K value)), объявленного в определенном базовом классе (или в\nреализуемом интерфейсе). Размер массива (таблицы) и конкретная\nхэш-функция (как ссылка на объект класса-наследника HashFunction)\nпередаются конструктору класса при создании объекта HashTable.",
    "10 задание": "Создайте класс Person, для хранения информации о\nчеловеке: фамилия, возраст и другие поля (какие и сколько решайте\nсами). Создайте класс-наследник HashFunction с какой-нибудь\nреализацией хэш-функции, получающей фамилию человека и\nвозвращающей целое значение (можно использовать алгоритм,\nописанный выше немного модифицировав его так, чтобы учесть\nмаксимально возможный размер массива, задаваемый извне).\nНапишите программу для тестирования работы хэш-таблицы,\nсодержащей объекты класса Person."
  },
  "6 лабораторная": {
    "1 задание": "Создайте приложение, отображающее в окне 300x300\nпикселей график кривой f(x) = sin(x) на интервале x от -π до π.",
    "2 задание": "Создайте класс Curve для отображения 2D-графика\nгладкой функции f(x) на заданном интервале изменения аргумента x. В\nклассе должны быть предусмотрены два массива (или один двумерный\nмассив) для хранения таблицы значений аргумента и функции, и метод\nsetData, позволяющий пользователю класса задавать данные для\nконкретной функции и конкретного интервала по x. Необходимо\nпредусмотреть методы для задания координат прямоугольной области,\nв которой должен отображаться график, и для отображения самого\nграфика. Создайте приложение, отображающий в окне 300x300\nпикселей график кривой f(x) = sin(x) на интервале x от 0 до 2*π с\nпомощью объекта класса Curve.",
    "3 задание": "Модифицируйте систему классов из задания 9\nлабораторной работы \"Классы в Java\": Graph, Axis, Curve так, чтобы\nпроисходило реальное отображение графика в окне приложения.",
    "4 задание": "Создайте приложение, в окне которого при щелчке мышью\nна месте курсора отображаются его координаты. Цвет отображения\nзадается пользователем с помощью клавиатуры. Клавиши b, w, r, g, o\nзадают цвет символов (b - black, w - white, r - red, g - green, o - orange)",
    "5 задание": "Создайте приложение, загружающее и отображающее\nнекоторое заданное в программе изображение из файла (JPEG или\nGIF). Изображение должно отображаться, занимая максимально\nвозможную часть окна, подстраиваясь под изменение размера окна\nпользователем, но при этом отношение ширины изображения к его\nвысоте должно оставаться неизменным (не должны меняться\nпропорции изображения). По щелчку мышью в области окна\nизображение в нем должно переворачиваться (поворачиваться на 180\nградусов).",
    "6 задание": "Эффект размытия (Blur) - каждая цветовая компонента\nпикселя (канал): красная, зеленая, синяя, заменяется на среднее\nзначение соответствующих каналов соседних пикселей (и самого\nтекущего пикселя). Например, можно взять область из 3x3 пикселей и\nрассмотреть центральный пиксель. Все остальные будут его\nближайшими соседями. Находим среднее значение для каждого из их\nцветовых каналов и заменяем на эти значения цветовые каналы\nцентрального пикселя. То же самое можно сделать для области 5x5\nпикселей и т.д. Эффект преобразования в серые цвета - цветное\nизображение преобразуется в оттенки серого цвета. Для каждого\nпикселя находится среднее его значений по разным каналам: красному,\nзеленому и синему. Затем каждый канал получает это среднее\nзначение. Измените программу из задания 5 так, чтобы с помощью\nклавиатуры можно было менять фильтры: вращение на 180 градусов -\nклавиша R или r, преобразование в оттенки серого (можно выполнить\nтолько один раз) - клавиша G или g, размытие - клавиша B или b (с\nучетом только ближайших соседей и самого пикселя). Собственно\nэффект возникает только после щелчка мышью по области окна.",
    "7 задание": "Создайте приложение с анимацией. По щелчку мышью\nсоздается в произвольной позиции окна круг заданного цвета со\nслучайным значением модуля скорости из некоторого диапазона.\nМожно задать для всех шариков направление скорости 45 градусов\nпротив часовой стрелки относительно горизонтальной оси. Шарики\nдвигаются и отражаются от стенок. Столкновения не обрабатываются.",
    "8 задание": "Создайте приложение \"Бегущая строка\". В программе\nзадается массив символьных строк (сообщений) и в окне программы\nпрокручивается одно из этих сообщение, за счет вывода этой строки\nтак, как будто она движется по экрану слева-направо. Щелчок мышью\n17\nдолжен приводить к смене сообщения, то есть к выбору (случайным\nобразом) другой строки из массива."
  },
  "7 лабораторная": {
    "1 задание": "Создайте приложение как объект класса-наследника\nJFrame. Разместите в главном окне комбобокс (JComboBox), метку\n(JLabel), кнопку (JButton), флажок с независимой фиксацией\n(JCheckBox), флажок с зависимой фиксацией (JRadioButton) и таблицу\n(JTable). Задайте для таблицы заголовки \"Язык\", \"Автор\" и \"Год\".\nПоместите в нее следующие данные: Си, Деннис Ритчи, 1972; C++,\nБьерн Страуструп, 1983; Python, Гвидо ван Россум, 1991; Java, Джеймс\nГослинг, 1995; JavaScript, Брендон Айк, 1995; C#, Андерс Хейлсберг,\n2001; Scala, Мартин Одерски, 2003. Запросите у системы доступные\nLAF. Поместите их названия в комбобокс. Создайте обработчик событий\n25\nдля комбобокс так, чтобы при выборе названия LAF оформление\nпрограммы переключалось на выбранный Look and Feel.",
    "2 задание": "Создайте приложение с элементами управления для\nзаданий 5 и 6 из лабораторной работы \"Рисование и обработка событий\nв пакетах AWT и Swing\". Подберите подходящие элементы управления.",
    "3 задание": "Создайте приложение с элементами управления для\nзаданий 7 и 8 из лабораторной работы \"Рисование и обработка событий\nв пакетах AWT и Swing\". Должны поддерживаться следующие\nвозможности: остановка, запуск анимации, задание максимально\nвозможного числа шариков. В бегущей строке должна отображаться\nинформация о количестве двигающихся в данное время шариков и о\nмаксимально возможном их количестве.",
    "4 задание": "Создайте приложение с элементами управления для\nзадания 3 из лабораторной работы \"Рисование и обработка событий в\nпакетах AWT и Swing\". Главное окно должно содержать две панели -\nпанель прорисовки графика функции и панель управления, которая\nдолжна содержать текстовые поля ввода для задания интервала\nизменения аргумента функции, комбобокс для выбора одной из трех\nфункций: sin(x), sin(x*x) + cos(x*x), 2*sin(x)+cos(2*x), кнопку для выбора\nцвета кривой на графике. Размеры панелей должны автоматически\nподстраиваться под размер главного окна программы при изменении\nего размеров. Для получения цвета кривой используйте JColorChooser.",
    "5 задание": "Создайте компонент, представляющий собой панель с\nтремя метками. Первая метка (upperLabel) занимает верхнюю часть\nпанели. Вторая (downLabel) - нижнюю часть. Третья (centerLabel) - центр\nпанели. Текст меток upperLabel и downLabel имеет следующие\nатрибуты: name - \"dialog\", type - Funt.BOLD | Font.Italic, size - 10, а метки\ncenterLabel - \"dialog”, Bald, 18 (см. метод setFont(java.awt.Font f)) и\nконструктор класса Font - Font(String name, int type, іnt size)). Для текста\nпервой метки должно быть задано горизонтальное выравнивание (см.\nметод setHorizontlalAlignment(int a)) влево, для второй — вправо, а для\nтретьей - по центру. Предусмотрите такие методы, чтобы можно было\nзадавать цвет фона панели и текст тобой метки (все эти параметры -\nсвойства компонента). Если фон окна закрашивается в методе paint(), а\nне раіtComponent(), не забудьте вызвать paint() базового класса для\nпрорисовки дочерних компонентов (в данном случае меток),\n26\nразмещенных на панели. Если есть такая возможность, используйте\nNetBeans (или другую IDE) для тестирования (и, быть может, создания)\nкомпонента",
    "6 задание": "Создайте компонент \"игральная кость\", выглядящий как\nквадрат, внутри которого могут размещаться от одного до шести\nзакрашенных кружков. Цвет кружков должен быть отдельным свойством,\nцвет фона (области внутри рамки) - другим свойством, а число кружков\n- третьим. Компонент должен реагировать на щелчок мышью, меняя\n(случайным образом) значение свойства \"число кружков\". Кроме того,\n\"кость\" должна иметь два состояния: активное и неактивное. В первом\nсобытие \"щелчок мышкой\" обрабатывается, во втором - игнорируется.\nЕсли есть такая возможность, используйте NetBeans (или другую IDE)\nдля тестирования (и, быть может создания) компонента.",
    "7 задание": "Создайте для компонентов из задания 5 и задания 6\nсоответствующие мета классы и простенькие изображения (иконки).\nЕсли есть такая возможность, добавьте компоненты на панель\nинструментов в NetBeans (или в другой IDE). Тогда нужно добиться,\nчтобы в редакторе свойств NetBeans (или в другой IDE) отображались\nтолько свойства самих компонентов, но не свойства, доставшиеся им от\nбазовых классов.",
    "8 задание": "Создайте игру (если есть такая возможность, то с помощью\nNetBeans или другой IDE) со следующими правилами:\n- играют двое;\n- каждый из них по очереди бросает свою собственную игральную кость;\n- выброшенное значение определяет число клеток игрового поля, на\nкоторое перемещается игрок;\n- с каждой клеткой поля связано положительное или отрицательное\nзначение (очки), либо одно из следующих действий - повтор хода,\nпотеря всех набранных очков, окончание игры;\n- при каждом перемещении игрока по полю, он получает или теряет\nсоответствующее число очков;\n- игрок, первым достигший финишной клетки, получает дополнительно\n50 очков;\n- игра продолжается до тех пор, пока один из игроков не попадет на\nфинишную клетку;\n- победил тот, y кого на момент окончания игры больше очков (о чем\nдолжно появиться соответствующее сообщение).\n27\nДля создания игры используйте компоненты из заданий 1 и 2. "
  }
}